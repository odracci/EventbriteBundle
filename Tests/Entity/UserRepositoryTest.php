<?php

namespace SFBCN\EventbriteBundle\Tests\Entity;

use SFBCN\EventbriteBundle\Entity\UserRepository;
use SFBCN\EventbriteBundle\Eventbrite\Mapper;
use Mockery as m;

/**
 * Generated by PHPUnit_SkeletonGenerator on 2012-05-09 at 00:49:58.
 */
class UserRepositoryTest extends \PHPUnit_Framework_TestCase
{
    /**
     * @var UserRepository
     */
    protected $object;

    /**
     * Tears down the fixture, for example, closes a network connection.
     * This method is called after a test is executed.
     */
    protected function tearDown()
    {
        $this->object = null;
    }

    /**
     * @covers SFBCN\EventbriteBundle\Entity\UserRepository::findUser
     */
    public function testFindVenue()
    {
        $command = m::mock('\Guzzle\Service\Command\AbstractCommand');

        $response = simplexml_load_string(<<<EOX
<?xml version="1.0" encoding="UTF-8" ?>
<user><id>1</id></user>
EOX
        );

        $mapper = m::mock('\SFBCN\EventbriteBundle\Eventbrite\Mapper');
        $mapper->shouldReceive('map')->with($response)->once()->andReturn('#user#');

        $client = m::mock('stdClass');
        $client->shouldReceive('getCommand')->with('user.get', array())->once()->andReturn($command);
        $client->shouldReceive('execute')->with($command)->once()->andReturn($response);

        $this->object = new UserRepository($client, $mapper);
        $result = $this->object->findUser();

        $this->assertEquals('#user#', $result);
    }

    /**
     * @covers SFBCN\EventbriteBundle\Entity\UserRepository::getEvents
     */
    public function testGetEvents()
    {
        $command = m::mock('\Guzzle\Service\Command\AbstractCommand');

        $response = simplexml_load_string(<<<EOX
<?xml version="1.0" encoding="UTF-8" ?>
<events>
    <event><id>1</id></event>
    <event><id>2</id></event>
</events>
EOX
        );

        $mapper = m::mock('\SFBCN\EventbriteBundle\Eventbrite\Mapper');
        $mapper->shouldReceive('map')->twice()->andReturn('#event1#', '#event2#');

        $client = m::mock('stdClass');
        $client->shouldReceive('getCommand')->with('user.events', array())->once()->andReturn($command);
        $client->shouldReceive('execute')->with($command)->once()->andReturn($response);

        $this->object = new UserRepository($client, $mapper);
        $result = $this->object->getEvents();

        $this->assertInternalType('array', $result);
        for ($i = 0; $i < sizeof($result); $i++) {
            $this->assertEquals('#event' . ($i + 1) . '#', $result[$i]);
        }
    }

    /**
     * @covers SFBCN\EventbriteBundle\Entity\UserRepository::getVenues
     */
    public function testGetVenues()
    {
        $command = m::mock('\Guzzle\Service\Command\AbstractCommand');

        $response = simplexml_load_string(<<<EOX
<?xml version="1.0" encoding="UTF-8" ?>
<venues>
    <venue><id>1</id></venue>
    <venue><id>2</id></venue>
</venues>
EOX
        );

        $mapper = m::mock('\SFBCN\EventbriteBundle\Eventbrite\Mapper');
        $mapper->shouldReceive('map')->twice()->andReturn('#venue1#', '#venue2#');

        $client = m::mock('stdClass');
        $client->shouldReceive('getCommand')->with('user.venues', array())->once()->andReturn($command);
        $client->shouldReceive('execute')->with($command)->once()->andReturn($response);

        $this->object = new UserRepository($client, $mapper);
        $result = $this->object->getVenues();

        $this->assertInternalType('array', $result);
        for ($i = 0; $i < sizeof($result); $i++) {
            $this->assertEquals('#venue' . ($i + 1) . '#', $result[$i]);
        }
    }

    /**
     * @covers SFBCN\EventbriteBundle\Entity\UserRepository::getOrganizers
     */
    public function testGetOrganizers()
    {
        $command = m::mock('\Guzzle\Service\Command\AbstractCommand');

        $response = simplexml_load_string(<<<EOX
<?xml version="1.0" encoding="UTF-8" ?>
<organizers>
    <organizer><id>1</id></organizer>
    <organizer><id>2</id></organizer>
</organizers>
EOX
        );

        $mapper = m::mock('\SFBCN\EventbriteBundle\Eventbrite\Mapper');
        $mapper->shouldReceive('map')->twice()->andReturn('#organizer1#', '#organizer2#');

        $client = m::mock('stdClass');
        $client->shouldReceive('getCommand')->with('user.organizers', array())->once()->andReturn($command);
        $client->shouldReceive('execute')->with($command)->once()->andReturn($response);

        $this->object = new UserRepository($client, $mapper);
        $result = $this->object->getOrganizers();

        $this->assertInternalType('array', $result);
        for ($i = 0; $i < sizeof($result); $i++) {
            $this->assertEquals('#organizer' . ($i + 1) . '#', $result[$i]);
        }
    }
}
